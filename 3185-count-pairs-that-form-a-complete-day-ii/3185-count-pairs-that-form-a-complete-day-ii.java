class Solution {
    /**
    완탐? 총 길이를 시간 초과가 뜰거임
    투썸 문제를 떠올려보자.
    map = hour : remain % 24
    [10, 14] : abs(10 - 24) % 24 = 14 -> 10
    [20, 52] : abs(20 - 24) % 24 = 4 -> 20
    52 / 24 = 2 (나머지 4)

    solution
    Set을 활용하여, hours를 순회하면서 값이 'abs(hour - 24) % 2'인 element가 있다면 횟수를 포함시키고
    없다면, 해당 element를 set에 add 한다.
    !! 근데 이 방법은 한번에 한 인덱스만 탐색하게 되므로 놓치는 케이스가 생긴다. (ex. [72,48,24] -> (0,1), (1, 2) 케이스만 카운팅함...)

    그래서 counting sort를 학습하고 다시 해봄
    countin sort -> 간단히 말해, 배열 하나를 해시맵처럼 쓰는 것이다. difference 정수 배열에 '키 -> 값'을 각각 '인덱스 번호 -> 카운팅 횟수'로 할당하여 카운팅하며 답을 도출해내는 기법

    따라서, difference의 인덱스 범위를 제대로 판단하는 것과 카운팅한 값을 적절하게 차감하여 정답을 도출해내는 것이 관건

    이번 문제의 경우, 결국 두 수의 합이 24의 배수인 경우의 수를 구하는 것이다.
    따라서 hours 를 순회하면서 hour를 24 모듈러 연산을 거쳐 index로 만들어 카운팅한 다음
     i/j의 합이 24인 difference 배열의 카운트 횟수를 차감하면 된다.

     실수1. differences 순회할때 enhanced for문을 쓴것
     실수2. 0, 12와 같이 동일한 수를 차감할때, 그냥 차감하는게 아니라 경우의 수를 구해야하는데 그러지 못한것
     실수3. 중복 숫자 처리의 경우, 순열과 조합을 내가 헷갈림...
     실수4. 중복 없는 숫자 처리의 경우, 차감할때 공식을 잘못 사용
     여기서 시간초과 오류 뜸... -> 조합으로 각각 카운트를 차감하면서 뭔가 예외처리해야할게 많아진다... 즉, 통과하지 못하는 사례가 생기고 그걸 막기 시작하면서 코드가 이상해짐..
     
    !! 그런데.. 순열과 조합을 써야만할까? 좀 더 단순화 해보자
    구하고자 하는 답은 아래와 같다.
    (hour[i] + hour[j]) % 24 == 0 인경우.
    그러나 hour의 수는 지나치게 크기 때문에 모듈러 연산으로 나머지로 환산할 필요가 있다.
    (hour[i] % 24 + hour[j] % 24) % 24 == 0 
        -> (x + y) % 24 = 0
        ->  x + y = 24
        ->  y = 24 - x
    이런 공식이 성립된다.
    즉, differences 배열에 24 - x를 탐색하고 카운팅하면 된다...


     */
    public long countCompleteDayPairs(int[] hours) {
        long count = 0;
        int[] differences = new int[24];

        for (int hour : hours) {
            int x = hour % 24;
            count += differences[(24 - x) % 24];
            differences[x]++;
        }

        return count;
    }
}